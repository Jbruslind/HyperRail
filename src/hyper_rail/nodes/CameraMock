#!/usr/bin/env python3

# This can be used for the basis of the camera node. Currently just hosts the
# camera service.

# The camera service currently takes in these service parametes
# uint32 program_run_id
# uint32 waypoint_id
# string action           # type of action to be sent this is kind of unnecessary, maybe switch with datapoint id?

from communication.camera_executor import *
import rospy
import time
from communication.constants import IMAGE_PATH, DEFAULT_CAMERA_HOST

from hyper_rail.srv import SensorService, SensorServiceRequest, SensorServiceResponse

#Called when service receives new request
def process_camera(req: SensorServiceRequest):
    # create a path for the program
    # query database program_run, way point
    camera_obj = Camera(IMAGE_PATH, req.program_run_id, req.waypoint_id)
    # TODO: utilize communication.camera_executor classes to capture ands store photos 

    # complete_path = "%s/%s/%s" % (IMAGE_PATH, req.program_run_id, req.waypoint_id)
    
    for i in range(3):
        print("sleeping", i)
        time.sleep(1)
    return("camera success")


def init_node():
    """Create the ros node and basic functionality"""
    rospy.init_node("CameraMock")

    # Sleep once per second. Just keeping the node alive
    publish_rate = rospy.Rate(1)

    # Service to receive camera commands
    service = rospy.Service("camera_service", SensorService, handler=process_camera)

    # Inform the user that the node and service have been started successfully
    rospy.loginfo(f"{rospy.get_name()}: serial connection established...") 

    while not rospy.is_shutdown():
        publish_rate.sleep()

if __name__ == "__main__":
    init_node()
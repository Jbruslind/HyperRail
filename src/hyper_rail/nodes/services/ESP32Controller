#!/usr/bin/env python3
"""Forwards commands along to the ESP32 GRBL to be interpreted"""

from hyper_rail.srv import GRBLService, GRBLServiceResponse, GRBLServiceRequest
import rospy

from serial.ESP32_Driver import SerialDriver
from communication.enums import RequestType, Axis

SERIAL_DRIVER = None

def on_service_contact(request: GRBLServiceRequest):
    global SERIAL_DRIVER
    packet_type = request.command_id

    # If there is data set it if not then there is no data
    data = request.command_data if (len(request.command_data) > 0) else None

    # Send generic GCODE 
    if packet_type == 0:
        return GRBLServiceResponse(SERIAL_DRIVER.send_gcode(data))

    # Home all axis of the machine
    elif packet_type == 1:
        return GRBLServiceResponse(SERIAL_DRIVER.home_machine(Axis.ALL))

    # Home X axis of the machine
    elif packet_type == 2:
        return GRBLServiceResponse(SERIAL_DRIVER.home_machine(Axis.X))

    # Home Y axis of the machine
    elif packet_type == 3:
        return GRBLServiceResponse(SERIAL_DRIVER.home_machine(Axis.Y))

    # Home Z axis of the machine
    elif packet_type == 4:
        return GRBLServiceResponse(SERIAL_DRIVER.home_machine(Axis.Z))

    # Set the ESP32 into a sleep mode
    elif packet_type == 5:
        return GRBLServiceResponse(SERIAL_DRIVER.sleep())
    
    # Send a jog command to the driver to move to a set position
    elif packet_type == 6:
        values = []

        # Create the required list of data to feed to the driver: X, Y and Feed rate
        # Formated as such: X<value> Y<value> F<value>
        values.append(float(data.split(" ")[0].replace("X", "").strip()))
        values.append(float(data.split(" ")[1].replace("Y", "").strip()))
        values.append(float(data.split(" ")[2].replace("F", "").strip()))
        
        # Drive the ESP32 to that position at the specified rate
        return GRBLServiceResponse(SERIAL_DRIVER.jog_machine(values[0], values[1], values[2]))

    # Get the current machine position
    elif packet_type == 7:
        return GRBLServiceResponse(SERIAL_DRIVER.get_position())
    
    # Wake-up the machine from sleep
    elif packet_type == 8:
        SERIAL_DRIVER.send_wakeup()
        return GRBLServiceResponse("Attempting Wake-up...")


def init_node():
    """Initialize a ROS node to run the service from and then start the service"""
    global SERIAL_DRIVER

    # Create a new serial driver 
    SERIAL_DRIVER = SerialDriver(115_200, "/dev/tty.usbmodem1811")

    # Start the node to run the service from
    rospy.init_node("GRBL_Controller_Service")

    # Start the service grbl_controller to handle communication with the ESP 32
    service = rospy.Service("grbl_controller", GRBLService, handler=on_service_contact)

    # Inform the user that the node and service have been started successfully
    rospy.loginfo(f"{rospy.get_name()}: awaiting requests...")

    # Wait for requests
    rospy.spin()


if __name__ == "__main__":
    init_node()


